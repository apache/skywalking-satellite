syntax = "proto3";



message Any {
  // A URL/resource name that uniquely identifies the type of the serialized
  // protocol buffer message. This string must contain at least
  // one "/" character. The last segment of the URL's path must represent
  // the fully qualified name of the type (as in
  // `path/google.protobuf.Duration`). The name should be in a canonical form
  // (e.g., leading "." is not accepted).
  //
  // In practice, teams usually precompile into the binary all types that they
  // expect it to use in the context of Any. However, for URLs which use the
  // scheme `http`, `https`, or no scheme, one can optionally set up a type
  // server that maps type URLs to message definitions as follows:
  //
  // * If no scheme is provided, `https` is assumed.
  // * An HTTP GET on the URL must yield a [google.protobuf.Type][]
  //   value in binary format, or produce an error.
  // * Applications are allowed to cache lookup results based on the
  //   URL, or have them precompiled into a binary to avoid any
  //   lookup. Therefore, binary compatibility needs to be preserved
  //   on changes to types. (Use versioned type names to manage
  //   breaking changes.)
  //
  // Note: this functionality is not currently available in the official
  // protobuf release, and it is not used for type URLs beginning with
  // type.googleapis.com.
  //
  // Schemes other than `http`, `https` (or the empty scheme) might be
  // used with implementation specific semantics.
  //
  string type_url = 1;

  // Must be a valid serialized protocol buffer of the above specified type.
  bytes value = 2;
}

// The segment is a collection of spans. It includes all collected spans in a simple one request context, such as a HTTP request process.
//
// We recommend the agent/SDK report all tracked data of one request once for all, such as,
// typically, such as in Java, one segment represent all tracked operations(spans) of one request context in the same thread.
// At the same time, in some language there is not a clear concept like golang, it could represent all tracked operations of one request context.
message SegmentObject {
  // A string id represents the whole trace.
  string traceId = 1;
  // A unique id represents this segment. Other segments could use this id to reference as a child segment.
  string traceSegmentId = 2;
  // Span collections included in this segment.
  repeated  Any spans = 3;
  // **Service**. Represents a set/group of workloads which provide the same behaviours for incoming requests.
  //
  // The logic name represents the service. This would show as a separate node in the topology.
  // The metrics analyzed from the spans, would be aggregated for this entity as the service level.
  string service = 4;
  // **Service Instance**. Each individual workload in the Service group is known as an instance. Like `pods` in Kubernetes, it
  // doesn't need to be a single OS process, however, if you are using instrument agents, an instance is actually a real OS process.
  //
  // The logic name represents the service instance. This would show as a separate node in the instance relationship.
  // The metrics analyzed from the spans, would be aggregated for this entity as the service instance level.
  string serviceInstance = 5;
  // Whether the segment includes all tracked spans.
  // In the production environment tracked, some tasks could include too many spans for one request context, such as a batch update for a cache, or an async job.
  // The agent/SDK could optimize or ignore some tracked spans for better performance.
  // In this case, the value should be flagged as TRUE.
  bool isSizeLimited = 6;
}